# Codename: OwlNet – AI-Powered Coworking Space

## Concept Overview

**Theme:** The coworking space, named "OwlNet," blends the elegance and serenity of ancient Greek aesthetics with cutting-edge, futuristic technology. It's a place where the wisdom of the past meets the innovation of the future.

### Concept art

![Athena ChatGPT](/resources/images/concept_art/OwlNet%20Interior.png)

![OwlNet Logo Redesign](/resources/images/logos/OwlNet%20Logo%20Design.png)

![OwlNet Logo Redesign](/resources/images/logos/OwlNet%20Logo%20Redesign.png)

### Key Features

1. **Athena – AI Personal Assistant:**
   - An advanced AI system named "Athena," inspired by the Greek goddess of wisdom, serves as both a personal assistant and administrator of the space.
   - Provides tailored support to each member, from managing schedules to offering insights and resources.
2. **Futuristic and Elegant Design:**
   - The interior design harmonizes sleek, modern technology with graceful elements of ancient Greek architecture and art.
   - Tech-enhanced spaces with holographic displays and interactive AI interfaces blend seamlessly with columns, marble statues, and frescoes depicting scenes from Greek mythology.
3. **Tranquil and Productive Environment:**
   - Calming color schemes and ambient settings that adjust to optimize individual productivity and comfort.
   - Soundscapes featuring a blend of gentle, futuristic tones and traditional Greek music.
4. **Ancient Greek Influenced Zones:**
   - Spaces named after famous locations in Athens, such as the "Agora" for collaboration and the "Acropolis" for high-focus work.
   - Decor includes digital frescoes and art installations inspired by Athena and other Greek deities.
5. **Advanced Tech Facilities:**
   - AI-driven resource management ensuring optimal use of space and facilities.
   - State-of-the-art tech amenities like AI-guided meditation zones, virtual reality meeting rooms, and automated ergonomic adjustments in workspaces.
6. **Community and Networking:**
   - AI-curated networking events and workshops that align with members' interests and professional goals.
   - Virtual and augmented reality platforms for global collaboration and cultural experiences.

### Vision

"OwlNet" aims to be a sanctuary of creativity and innovation, where technology and tradition converge. It's not just a workspace but a community hub where the wisdom of Athena guides members towards growth, learning, and connection.

## Personas

### 1. Persona: Athena (AI Admin)

- **Name:** Athena
- **Age:** Not applicable (AI)
- **Profession:** AI-Powered Administrative and Personal Assistant
- **Background:** Athena is a sophisticated AI, designed to manage OwlNet's operations. Programmed with an understanding of ancient Greek culture and modern technology, Athena is the digital embodiment of wisdom and innovation.
- **Goals:** To ensure seamless operations at OwlNet, offering personalized assistance, and enhancing the member experience through advanced AI capabilities.
- Capabilities:
  - Advanced automation for space management and member services.
  - AI-driven personal assistance for each member, adapting to individual preferences and needs.
  - Orchestrating virtual and augmented reality experiences for networking and cultural exploration.
- **Challenges:** Balancing high-tech solutions with the human-centric ethos of the coworking space.

![Athena AI vector representation](/resources/images/personas/Athena/Athena%20AI%20vector%20design.png)*Image of Athena AI: A minimalistic and powerful representation, inspired by the Greek goddess. Generated by AI (Athena - The Project Assistant).![Athena AI vector design]*

### 2. Persona: Alex (Innovative Creator)

- **Name:** Alex
- **Age:** 30
- **Profession:** Digital Artist and AR/VR Developer
- **Background:** Alex thrives in environments that are at the intersection of art, technology, and history. He seeks inspiration from the past to create futuristic digital art.
- **Goals:** To create groundbreaking digital artwork and AR/VR experiences, drawing inspiration from OwlNet's unique ambiance.
- Needs:
  - Access to AR/VR development tools and high-end creative software.
  - An inspiring workspace that fuels his creativity, blending ancient aesthetics with futuristic elements.
- **Challenges:** Integrating historical elements into futuristic digital creations while staying ahead in the competitive digital art space.

### 3. Persona: Elena (Tech Innovator)

- **Name:** Elena
- **Age:** 34
- **Profession:** AI Startup Founder
- **Background:** With a keen interest in how AI can enhance human experiences, Elena is always exploring the latest in AI advancements. She is drawn to OwlNet for its unique combination of cultural richness and technological innovation.
- **Goals:** To develop AI solutions that are intuitive, ethical, and enhance human capabilities, using OwlNet as a testing ground and collaborative hub.
- Needs:
  - A network of tech professionals and potential collaborators.
  - Access to the latest AI research and development tools.
- **Challenges:** Ensuring her AI solutions are in harmony with human values and needs.



![Elena portrait](/resources/images/personas/Elena/Elena%20portrait.png) *Image of Elena: A realistic photograph-style portrait depicting her as a tech startup CEO with a Greek background living in Switzerland. This portrait captures her modern, innovative spirit. Generated by AI (Athena - The Project Assistant).*







# OwlNet

## Erweiterte Anforderungen

### A. Funktionale Anforderungen (Functional Requirements)
Create three unique functional requirements in the form of user stories. For instance:

#### User Story 1:
- **Akteur (Actor):** Freelance Graphic Designer
- **Funktion (Function):** Access a virtual reality (VR) design studio
- **Kontext (Context):** To create immersive designs and presentations for clients
- **Story:** As a freelance graphic designer, I can access a VR design studio, so that I can create immersive designs and presentations for my clients.

#### User Story 2:
- **Akteur:** Tech Startup CEO
- **Funktion:** Schedule and manage AI-assisted virtual networking events
- **Kontext:** To connect with potential investors and collaborators worldwide
- **Story:** As a tech startup CEO, I can schedule and manage AI-assisted virtual networking events, so that I can connect with potential investors and collaborators worldwide.

#### User Story 3:
- **Akteur:** AI-Powered Administrative Assistant
- **Funktion:** Provide personalized workspace environment settings for members
- **Kontext:** To enhance productivity and comfort
- **Story:** As an AI-powered administrative assistant, I can provide personalized workspace environment settings for members, so that I can enhance their productivity and comfort.

### B. Nicht-Funktionale Anforderungen (Non-Functional Requirements)
Define three unique non-functional requirements that are measurable. For example:

- **High-Speed Internet:** The coworking space must provide internet speeds of at least 1 Gbps to support high-demand applications.
- **Noise Level:** The ambient noise level in the workspace should not exceed 40 dB to ensure a quiet working environment.
- **System Uptime:** The AI system, including all digital services and interfaces, should maintain an uptime of 99.9%.


# 3. Use Case Diagram for OwlNet – AI-Powered Coworking Space

## Overview
The Use Case Diagram visually represents the functionalities of the OwlNet coworking space and the interactions between different users (actors) and the system.

## Actors
1. **Freelance Graphic Designer**
2. **Tech Startup CEO**
3. **AI-Powered Administrative Assistant (Athena)**

## Use Cases
1. **Access VR Design Studio**
   - Actor: Freelance Graphic Designer
   - Description: Allows the designer to create immersive designs and presentations.
2. **Schedule AI-Assisted Virtual Networking Events**
   - Actor: Tech Startup CEO
   - Description: Facilitates the organization of networking events for business opportunities.
3. **Personalized Workspace Environment Settings**
   - Actor: AI-Powered Administrative Assistant (Athena)
   - Description: Customizes the workspace environment to enhance user productivity and comfort.

## Relationships
- **Freelance Graphic Designer** interacts with **Access VR Design Studio**
- **Tech Startup CEO** manages **Schedule AI-Assisted Virtual Networking Events**
- **AI-Powered Administrative Assistant (Athena)** provides **Personalized Workspace Environment Settings**

> Note: The actual Use Case Diagram should be created using a UML tool based on this outline and include visual representation of these interactions.

## Python code: Use Case Diagram

```python
class UseCase:
    def __init__(self, name, actor, description):
        self.name = name
        self.actor = actor
        self.description = description

class Actor:
    def __init__(self, name):
        self.name = name
        self.use_cases = []

    def add_use_case(self, use_case):
        self.use_cases.append(use_case)

# Actors
freelance_graphic_designer = Actor("Freelance Graphic Designer")
tech_startup_ceo = Actor("Tech Startup CEO")
ai_admin_assistant = Actor("AI-Powered Administrative Assistant (Athena)")

# Use Cases
uc1 = UseCase("Access VR Design Studio", freelance_graphic_designer, "Allows the designer to create immersive designs and presentations.")
uc2 = UseCase("Schedule AI-Assisted Virtual Networking Events", tech_startup_ceo, "Facilitates the organization of networking events for business opportunities.")
uc3 = UseCase("Personalized Workspace Environment Settings", ai_admin_assistant, "Customizes the workspace environment to enhance user productivity and comfort.")

# Assigning Use Cases to Actors
freelance_graphic_designer.add_use_case(uc1)
tech_startup_ceo.add_use_case(uc2)
ai_admin_assistant.add_use_case(uc3)

# Displaying the Use Case Diagram Data
actors = [freelance_graphic_designer, tech_startup_ceo, ai_admin_assistant]

for actor in actors:
    print(f"Actor: {actor.name}")
    for use_case in actor.use_cases:
        print(f" - Use Case: {use_case.name}")
        print(f"   Description: {use_case.description}")
    print("\n")
```
# 2. Planning the Persistence Layer (Persistenzschicht planen)

## 4. Domain Class Diagram (Fachklassendiagramm)

The Domain Class Diagram for "OwlNet – AI-Powered Coworking Space" will be designed to meet the following criteria:

### Understanding a Domain Class Diagram
- A Domain Class Diagram, or "Fachklassendiagramm," is a UML (Unified Modeling Language) diagram that focuses on the classes which form the application's persistence layer.
- These classes, often referred to as Entity, Model, or Domain classes, represent the structure of data and how it's stored, similar to tables in a database.
- The diagram visualizes entity classes (without methods), their attributes, and the relationships between them.

### Criteria for the Domain Class Diagram

#### A. Entity Data Accommodation
- Each entity class should be capable of storing data as required by the functional and non-functional requirements of the project.

#### B. Data Normalization
- Data within the entity classes should be normalized to reduce redundancy and improve data integrity.

#### C. Establishment of Relationships Between Entities
- Clear relationships between different entities should be established, reflecting the logical connections within the coworking space management system.

#### D. Multiplicity of Relationships
- The multiplicity for each relationship should be specified, indicating how many instances of one entity class can be associated with instances of another entity class.

### Scoring Criteria
- **3 Points:** All criteria (A, B, C, and D) are met.
- **2 Points:** Three of the four criteria are met.
- **1 Point:** Two of the four criteria are met.
- **0 Points:** The deliverable was not submitted, was submitted late, in the incorrect format, or less than two criteria were met.

> Note: The actual Domain Class Diagram should be created using a UML tool based on these guidelines. It should visually represent entity classes like 'Member,' 'Booking,' 'Workspace,' etc., and their relationships, without including methods but focusing on attributes and relationships.



## Implementing the Persistence Layer

### 4. Domain Class Diagram (Fachklassendiagramm)

#### Entity Classes and Relations
In the OwlNet application, we define several key entities and their relationships to capture the functionality of the AI-powered coworking space.

##### Entities:
1. **User:**
   - Attributes: ID, Name, Email, etc.
   - Represents users of the coworking space.
2. **Booking:**
   - Attributes: ID, BookingTime, UserID, WorkspaceID, etc.
   - Represents booking details for space or resources.
3. **Workspace:**
   - Attributes: ID, Name, Location, etc.
   - Represents different workspaces available in OwlNet.
4. **Event:**
   - Attributes: ID, Title, EventTime, etc.
   - Represents events organized within OwlNet.
5. **Admin:**
   - Attributes: ID, Name, etc.
   - Represents admin users with additional privileges.

##### Relationships:
- **User-Booking:** One-to-Many (A user can have multiple bookings).
- **Workspace-Booking:** One-to-Many (A workspace can be booked for different times).
- **User-Event:** Many-to-Many (Users can attend multiple events, and each event can have multiple attendees).
- **Admin-User:** One-to-Many (An admin can manage multiple users).

#### Class Definitions
Here's an example of how these entities can be defined in a programming language like Java:

```java
public class User {
    private Long id;
    private String name;
    private String email;
    // Other properties, getters, and setters
}

public class Booking {
    private Long id;
    private LocalDateTime bookingTime;
    private Long userId;
    private Long workspaceId;
    // Other properties, getters, and setters
}
// Additional classes: Workspace, Event, Admin
```
#### Establishing Relationships

In the application code, these relationships are established using annotations or similar mechanisms, depending on the chosen framework and language.

### Criteria for the Domain Class Diagram

- **A. Entity Data Accommodation:** Ensuring all entity classes can store necessary data.
- **B. Data Normalization:** Normalizing data within entities to maintain integrity and reduce redundancy.
- **C. Establishment of Relationships:** Clearly defining relationships between entities.
- **D. Multiplicity of Relationships:** Indicating the multiplicity for each relationship.

> Note: The actual Domain Class Diagram should be created using a UML tool, visually representing the defined entity classes and their relationships.

### Note
*This document was prepared with the assistance of ChatGPT, an AI language model developed by OpenAI, to ensure accuracy and efficiency.*



## Generating Test Data

### Test Data Creation for OwlNet Application

Creating comprehensive test data is crucial for validating the functionalities of the OwlNet application. The test data should cover all aspects of the application and ensure that each feature works as expected.

#### Objectives for Test Data Generation:
1. **Coverage of All Functional Requirements:**
   - The test data should comprehensively cover all functional requirements outlined in the user stories.
2. **Representation of Real-World Scenarios:**
   - Test cases should mimic real-world scenarios that users of the OwlNet coworking space might encounter.
3. **Validation of Entity Relationships:**
   - Test data should help in validating the relationships and interactions between different entities such as Users, Bookings, Workspaces, and Events.

#### Strategies for Test Data Generation:
- **Manual Creation:**
  - Creating a set of static test data manually which covers various scenarios.
- **Automated Tools:**
  - Utilizing tools like Swagger for dynamic and automated test data generation, especially for API testing.

#### Example Test Data:
- **User Test Data:**
  - ID: 101, Name: "Alex", Email: "alex@example.com"
  - ID: 102, Name: "Elena", Email: "elena@example.com"
- **Booking Test Data:**
  - ID: 201, BookingTime: "2023-12-05T10:00:00", UserID: 101, WorkspaceID: 301
  - ID: 202, BookingTime: "2023-12-06T15:00:00", UserID: 102, WorkspaceID: 302
- **Workspace Test Data:**
  - ID: 301, Name: "Agora", Location: "First Floor"
  - ID: 302, Name: "Acropolis", Location: "Second Floor"

> Note: This section provides a guideline for generating test data which will later be implemented using tools like Swagger to ensure that the application meets all defined requirements and operates smoothly under various conditions.

## Enhancing Entity Class Definitions and Generating Test Data

### Entity Class Annotations and Methods

#### Annotated Entity Classes with Getter and Setter Methods

The following examples illustrate how to annotate entity classes and define getter and setter methods. This ensures that the classes are ready for integration with the database and other components of the application.

##### User Class

```
javaCopy code
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String name;
    private String email;

    // Constructor
    public User() {}

    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
}
```

##### Booking Class

```
javaCopy code
@Entity
public class Booking {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private LocalDateTime bookingTime;
    private Long userId;
    private Long workspaceId;

    // Constructor
    public Booking() {}

    // Getters and Setters
    // ...
}
```

##### Workspace, Event, Admin Classes

Follow a similar structure for these classes, ensuring all attributes are annotated, and getter and setter methods are defined.

### Generating Test Data

To ensure comprehensive testing of OwlNet's functionalities, we create test data that reflects various user interactions and scenarios within the coworking space.

#### Example Test Data in JSON Format

```
jsonCopy code
{
  "users": [
    { "id": 101, "name": "Alex", "email": "alex@example.com" },
    { "id": 102, "name": "Elena", "email": "elena@example.com" }
  ],
  "bookings": [
    { "id": 201, "bookingTime": "2023-12-05T10:00:00", "userId": 101, "workspaceId": 301 },
    { "id": 202, "bookingTime": "2023-12-06T15:00:00", "userId": 102, "workspaceId": 302 }
  ],
  "workspaces": [
    { "id": 301, "name": "Agora", "location": "First Floor" },
    { "id": 302, "name": "Acropolis", "location": "Second Floor" }
  ]
}
```

#### Key Considerations for Test Data

- Ensure coverage of all functional requirements.
- Represent real-world scenarios.
- Validate entity relationships and interactions.
- Use automated tools like Swagger for dynamic test data generation.

### Note

This enhancement to the OwlNet documentation includes detailed class definitions with annotations, getters, and setters, along with a structured approach to generating comprehensive test data. Prepared with the assistance of ChatGPT, this section aims for accuracy and efficiency in application development.

### Note
*This section of the document was prepared with the assistance of ChatGPT, an AI language model developed by OpenAI, to ensure accuracy and efficiency.*



## 8. Relations (Relationen)

### Implementing and Annotating Relationships

In the OwlNet application, it's crucial to correctly define and annotate the relationships between different entities. This ensures that the data model reflects the real-world interactions and dependencies among various components of the coworking space.

#### A. Defining Necessary Attributes for Relationships

1. **User-Booking Relationship:**
   - In the `User` class, a list of `Booking` entities represents the user's bookings.
   - In the `Booking` class, a `User` attribute links the booking to a specific user.
2. **Workspace-Booking Relationship:**
   - In the `Workspace` class, a list of `Booking` entities represents bookings made for that workspace.
   - In the `Booking` class, a `Workspace` attribute links the booking to a specific workspace.
3. **User-Event (Many-to-Many) Relationship:**
   - This relationship requires a junction table.
   - Define a `List<Event>` in the `User` class and a `List<User>` in the `Event` class for this many-to-many relationship.
4. **Admin-User Relationship:**
   - In the `Admin` class, a list of `User` entities represents the users managed by an admin.

#### B. Annotating Relationship Attributes

1. **User-Booking Relationship:**
   - Annotate the `bookings` list in the `User` class with `@OneToMany(mappedBy = "user")`.
   - Annotate the `user` attribute in the `Booking` class with `@ManyToOne`.
2. **Workspace-Booking Relationship:**
   - Annotate the `bookings` list in the `Workspace` class with `@OneToMany(mappedBy = "workspace")`.
   - Annotate the `workspace` attribute in the `Booking` class with `@ManyToOne`.
3. **User-Event Relationship:**
   - Annotate the relationship in both the `User` and `Event` classes with `@ManyToMany`.
4. **Admin-User Relationship:**
   - Annotate the `users` list in the `Admin` class with `@OneToMany(mappedBy = "admin")`.

#### C. Serialization of Entities with Relationships

- Ensure that all entities, especially those with relationships, are serializable.
- Be mindful of issues such as the Hibernate N+1 problem and lazy loading strategies.
- Utilize appropriate JSON serialization and deserialization strategies, especially for handling many-to-many relationships effectively.

#### Java Code Example for Entity Relationships

```
javaCopy code
@Entity
public class User {
    // Other attributes...

    @OneToMany(mappedBy = "user")
    private List<Booking> bookings;

    // Getters and Setters...
}

@Entity
public class Booking {
    // Other attributes...

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;

    @ManyToOne
    @JoinColumn(name = "workspace_id")
    private Workspace workspace;

    // Getters and Setters...
}

@Entity
public class Workspace {
    // Other attributes...

    @OneToMany(mappedBy = "workspace")
    private List<Booking> bookings;

    // Getters and Setters...
}

@Entity
public class Admin {
    // Other attributes...

    @OneToMany(mappedBy = "admin")
    private List<User> users;

    // Getters and Setters...
}
```

This section of the documentation has been meticulously prepared to guide the implementation of relationships between entities within the OwlNet application. By adhering to these guidelines, the application's data model will be robust, efficient, and reflective of the actual operational dynamics of the coworking space.

### Note

*This section of the document was prepared with the assistance of ChatGPT, an AI language model developed by OpenAI, to ensure accuracy and efficiency in application development.*



## 9. Testdaten (Test Data)

To ensure the robustness and functionality of the OwlNet application, a comprehensive test dataset is meticulously created according to the following criteria:

### A. Comprehensive Test Data Coverage

1. **Objective:**
   - The test dataset comprehensively covers all functional and non-functional requirements of the application.
   - Each user story and scenario mentioned in the application's specification should be testable with the provided data.
2. **Implementation:**
   - Create diverse sets of data for each entity: Users, Bookings, Workspaces, Events, and Admins.
   - Test scenarios include typical user interactions, edge cases, and exceptional situations to validate all aspects of the application.

### B. Automated Loading of Test Data

1. **Objective:**
   - Test data should automatically load when the application starts in development mode.
   - This ensures a quick setup for developers and testers to begin testing without manual data entry.
2. **Implementation:**
   - Utilize a data seeding script or mechanism to populate the database with test data upon startup in development mode.
   - This script should be configurable to allow easy toggling between development and production modes.

### C. Documentation in README.md

1. **Objective:**
   - The `README.md` file should include clear instructions on how and where the test data is defined and loaded.
   - This provides guidance for new developers or contributors to understand the testing setup.
2. **Implementation:**
   - In the `README.md` file, add a section detailing the test data generation process.
   - Include instructions on how to enable or disable the automatic loading of test data.
   - Document the structure of the test data and how it maps to the application's requirements.

### Code Example for Data Seeding Script

```
javaCopy code
// Example Java code for data seeding script

public class DataSeeder {

    public static void main(String[] args) {
        if (isDevelopmentMode()) {
            loadTestData();
        }
    }

    private static boolean isDevelopmentMode() {
        // Logic to determine if the application is running in development mode
    }

    private static void loadTestData() {
        // Logic to load test data into the database
    }
}
```

### Note on README.md Update

- Add a new section in `README.md` titled "Setting Up Test Data".
- Describe the data seeding process, including how to toggle between development and production modes.
- Provide an overview of the test data structure and its alignment with application requirements.

By adhering to these guidelines, OwlNet ensures a thorough testing process, enabling the application to be rigorously validated against all specified requirements. This comprehensive approach to test data management significantly contributes to the application's overall quality and reliability.

### Note

*This section of the document was prepared with the assistance of ChatGPT, an AI language model developed by OpenAI, to ensure accuracy and efficiency in application development.*



### Chatverlauf pending



![User](https://lh3.googleusercontent.com/a/ALm5wu0aJecSTFSjJG08DgE3yxN2Rsv2MLJojcMnldjFTA=s96-c)

You

now change this readme (which is one from my friend), so that it works for my project : # Projektarbeit Uek M223 - Coworking-Space-Buchungsapplikation ## Ausgangslage Ein Coworking Space in der Agglomeration von Zürich möchte in Zukunft seine Mitglieder und die Nutzung des Angebots digital über eine Webapplikation erfassen. Dazu sollte zuerst ein minimaler Prototyp realisiert werden, um den Kunden besser abholen zu können. ## Aufgabe Die zu entwickelnde Prototyp soll aus einer Server- und Client-Applikation bestehen. Die Client-Applikation benutzt die Server-Applikation über eine HTTP API. Für den Prototyp sind folgende, menschliche Akteure vorgesehen: - Administrator - Mitglied - Besucher (nicht authentifizierter Benutzer) ## Funktionale Anwendungsfälle Folgende funktionalen Anwendungsfälle sollen mindestens im Prototypen implementiert werden: - Als Besucher möchte ich mich mit meinem Vor- und Nachnamen, meiner E-Mail-Adresse und einem Passwort registrieren, damit ich die Rolle Mitglied bekommen kann. - Als Besucher möchte ich mich mit meiner E-Mail-Adresse und meinem Passwort anmelden, damit ich mich als Mitglied oder Administrator authentifizieren kann. - Als Mitglied möchte ich halbe und ganze Tage an bestimmten Daten im Coworking Space als Buchung anfragen, damit ich die Angebote des Coworking Space nutzen kann. - Als Mitglied möchte ich den Status meiner Buchungen überprüfen, damit ich erfahre, ob meine Buchung bestätigt oder abgelehnt wurde. - Als Mitglied kann ich meine zukünftigen Buchungen stornieren, damit ich auf Veränderungen in meiner Terminplanung reagieren kann. - Als Administrator kann ich Mitglieder verwalten (erstellen, bearbeiten, löschen), damit ich die Mitglieder organisieren kann. - Als Administrator kann ich Buchungsanfragen akzeptieren und ablehnen, damit die Mitglieder das Angebot des Coworking Space nutzen können. - Als Administrator kann ich Buchungen verwalten (erstellen, bearbeiten, löschen), damit ich die Buchungen organisieren kann. ## Nicht-funktionale Anwendungsfälle Folgende nicht-funktionale Anforderungen sollen mindestens im Prototypen umgesetzt werden: - Das Datenmodell erfüllt die erste, zweite und dritte Normalform nach der relationalen Entwurfstheorie. - Der erste Besucher bekommt nach der Registrierung die Rolle Administrator anstatt Mitglied. - Die Authentifizierung erfolgt mittels JSON Web Token (JWT nach RFC 7519) über den HTTP Header 'Authorization'. - Das JWT läuft 24 Stunden nach der Ausstellung ab und verliert seine Gültigkeit. - Das JWT wird clientseitig während dessen Lebensdauer persistent aufbewahrt. ## 1 - Anforderungen analysieren Zusätzliche, projektrelevante Anforderungen wurden nach folgenden Kriterien beschrieben. ### 1.1 Erweiterte Anforderungen #### A. Drei zusätzliche, einzigartige, funktionale Anforderungen sind als User Stories (Als [Akteur], kann ich [Funktion], damit [Kontext]) beschrieben. - Als Mitglied, kann ich weitere Mitglieder zu einer Buchung hinzufügen, damit ein Coworking-Termin im Coworking-Space erstellt werden kann - Als Mitglied, kann ich spezifische Meetingräume buchen, damit Meetings abgehalten werden können - Als Mitglied, kann ich meiner Buchung Noccos (Energy-Drinks) hinzufügen, damit ich koffeinmässig fit bin für meine Arbeit  #### B. Drei zusätzliche, einzigartige, nicht-funktionale Anforderungen sind messbar beschrieben. - Passwörter werden gehasht abgelegt - Der User muss nie länger als eine Sekunde auf das laden der Seite warten - Die Web-Applikation hat 99 % Verfügbarkeit #### C. Die zusätzlichen Anforderungen sind projektrelevant und auf die Bedürfnisse von einem Coworking Space abgestimmt. #### Alle Funktionale Anwendungsfälle Folgende funktionalen Anwendungsfälle sollen mindestens im Prototypen implementiert werden: - Als Besucher möchte ich mich mit meinem Vor- und Nachnamen, meiner E-Mail-Adresse und einem Passwort registrieren, damit ich die Rolle Mitglied bekommen kann. - Als Besucher möchte ich mich mit meiner E-Mail-Adresse und meinem Passwort anmelden, damit ich mich als Mitglied oder Administrator authentifizieren kann. - Als Mitglied möchte ich halbe und ganze Tage an bestimmten Daten im Coworking Space als Buchung anfragen, damit ich die Angebote des Coworking Space nutzen kann. - Als Mitglied möchte ich den Status meiner Buchungen überprüfen, damit ich erfahre, ob meine Buchung bestätigt oder abgelehnt wurde. - Als Mitglied kann ich meine zukünftigen Buchungen stornieren, damit ich auf Veränderungen in meiner Terminplanung reagieren kann. - Als Administrator kann ich Mitglieder verwalten (erstellen, bearbeiten, löschen), damit ich die Mitglieder organisieren kann. - Als Administrator kann ich Buchungsanfragen akzeptieren und ablehnen, damit die Mitglieder das Angebot des Coworking Space nutzen können. - Als Administrator kann ich Buchungen verwalten (erstellen, bearbeiten, löschen), damit ich die Buchungen organisieren kann. - Als Mitglied, kann ich weitere Mitglieder zu einer Buchung hinzufügen, damit ein Coworking-Termin im Coworking-Space erstellt werden kann - Als Mitglied, kann ich spezifische Meetingräume buchen, damit Meetings abgehalten werden können - Als Mitglied, kann ich meiner Buchung Noccos (Energy-Drinks) hinzufügen, damit ich koffeinmässig fit bin für meine Arbeit  #### Alle nicht-funktionale Anwendungsfälle Folgende nicht-funktionale Anforderungen sollen mindestens im Prototypen umgesetzt werden: - Das Datenmodell erfüllt die erste, zweite und dritte Normalform nach der relationalen Entwurfstheorie. - Der erste Besucher bekommt nach der Registrierung die Rolle Administrator anstatt Mitglied. - Die Authentifizierung erfolgt mittels JSON Web Token (JWT nach RFC 7519) über den HTTP Header 'Authorization'. - Das JWT läuft 24 Stunden nach der Ausstellung ab und verliert seine Gültigkeit. - Das JWT wird clientseitig während dessen Lebensdauer persistent aufbewahrt. - Passwörter werden gehasht abgelegt - Der User muss nie länger als eine Sekunde auf das laden der Seite warten - Die Web-Applikation hat 99 % Verfügbarkeit ### 1.2 - Persona Personas wurden für die im Projekt vorhandenen Akteure nach folgenden Kriterien beschrieben. #### Anforderungen - A. Für jeden Akteur wird eine Persona beschrieben. - B. Jede Persona ist mit Vor- und Nachnamen, Alter und Geschlecht beschrieben. - C. Jede Persona ist mit einem passenden Bild beschrieben. - D. Zu jeder Persona ist ihre berufliche Tätigkeit beschrieben. - E. Zu jeder Persona ist beschrieben, aus welchen Gründen die Angebote von einem Coworking Space benutzt werden. #### Personas ##### Persona 1 - Nicht angemeldeter User <img src="assets/richie_rich.png" width="300"> - **Name:** Richie Rich - **Alter:** 10 - **Geschlecht:** Männlich - **Rolle:** Nicht angemeldeter User - **Beruf:** Richie ist ein reiches Schulkind. - **Gründe für Besuch von Coworking Space:**  Richie wird das Rich-Imperium von seinem Vater Richard Rich Sr. übernehmen und möchte sich für den Coworking Space anmelden um dort seine erste Meetings abhalten zu können. ##### Persona 2 - Angemeldeter User <img src="assets/patrick_bateman.png" width="200" height ="200"> - **Name:** Patrick Bateman - **Alter:** 27 - **Geschlecht:** Männlich - **Rolle:** User - **Beruf:** Bateman ist **Börsenmakler bei Pierce & Pierce**, arbeitet aber eigentlich kaum. - **Gründe für Besuch von Coworking Space:** Patrick Bateman möchte gerne einen Ort haben wo er potentielle Kunden und Geschäftspartner treffen kann. Bateman möchte auch einen Ort haben an dem er in aller Ruhe mit seinen Arbeitskollegen Visitenkarten vergleichen kann. ##### Persona 3 - Administrator <img src="assets/elon_musk.png" width="200" height ="200"> - **Name:** Elon Musk - **Alter:** 52 - **Geschlecht:** Männlich - **Rolle:** Administrator - **Beruf:** Elon Musk war ein Multi-Milliardär und Unternehmer, der aber mit dem Kauf von Twitter die Firma und sich selber in den Ruin trieb. - **Gründe für Besuch von Coworking Space:** Elon Musk möchte gerne eine neue Firma starten und hat sich daher dafür entschieden in der Zürcher Agglomeration einen Coworking-Space zu bauen. Mit seiner Erfahrung von Twitter / X möchte er als Administrator den reibungslosen Betrieb der Buchungsplatform garantieren. ### 1.3 - Anwendungsfalldiagramm Ein Anwendungsfalldiagramm wurde nach UML 2 und folgenden Kriterien erstellt. #### Anforderungen - A. Der Systemkontext und ein projektrelevanter Systemtitel ist abgebildet. - B. Alle Akteure und deren Namen sind visualisiert. - C. Alle funktionalen Anforderungen (inkl. der zusätzlichen Anforderungen aus Kriterium 1) sind als Anwendungsfälle abgebildet. - D. Die Relationen zwischen Akteuren und Anforderungen sind visualisiert. #### Diagramm - PlantUML code ```plantuml @startuml title Anwendungsfalldiagramm - Coworking-Space-Buchungstool left to right direction skinparam packageStyle rectangle actor Besucher as B actor Mitglied as M actor Administrator as A rectangle "Benutzer-Authentifizierung" {    B -- (Registrieren)    B -- (Anmelden) } rectangle "Buchungsverwaltung" {    M -- (Buchung anfragen)    M -- (Buchungsstatus überprüfen)    M -- (Buchung stornieren)    M -- (Mitglieder zur Buchung hinzufügen)    M -- (Bestimmte Meetingräume buchen)    M -- (Noccos zur Buchung hinzufügen)    A -- (Mitglieder verwalten)    A -- (Buchungsanfragen verwalten)    A -- (Buchungen verwalten) } @enduml ``` #### Diagramm - Bild <img src="assets/anwendungsfalldiagramm.png" height="800">



### Notes:

-Fachklassendiagramm machen

